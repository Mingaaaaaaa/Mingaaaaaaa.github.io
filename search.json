[{"title":"c语言程序设计周","url":"/2022/05/22/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%91%A8/","content":"（搭了一个博客这么久都没有写过什么东西，试试手）\n​ 本文记录作者在大一下册程序设计周的过程。\n​ 本次作业是三人合作实现一个连连看的游戏（C 语言）\n刚看到题目时觉得游戏难度不小，主要原因还是上个学期的 C 语言没有什么程序设计的经验，无非是写写运算和熟悉语法。所有刚开始的两天队友也都没什么动静，摆了两天。后来开始作业，我负责了菜单的设计（全是 printf,乐）没有什么难度，后来写了生成矩阵，计时功能，数据录入，和最后的完善（老师提的提示功能）\n消除逻辑部分接触不多，自己没有想透彻，队友解决了！此时也才花了二三天的时间。后面一周干了什么不太有印象了\n总之，本次游戏的难点在于 消除算法的实现 和 restart 的逻辑，\n后来答辩时也没有完全符合题目需求（答辩迟迟不开展拖了一个月，真无语），答辩后重新审视代码，确实和题目要求有不小的出入，比如地图的生成靠随机数是很睿智的选择，restart 直接换一批更是重量级！真不知道当时咋想的（我是啥 b)，提示功能和第一次生成地图不能死局的实现是类似的，答辩后队友纷纷开摆，作者只能把上面的缺陷慢慢修补（restart 不是俺写的，虽然是把所剩字母放在数组里打乱顺序再替换原来的地图）\n总结如下:\n\n"},{"title":"使用CSS和JS实现灵动岛动画","url":"/2022/10/03/%E4%BD%BF%E7%94%A8CSS%E5%92%8CJS%E5%AE%9E%E7%8E%B0%E7%81%B5%E5%8A%A8%E5%B2%9B%E5%8A%A8%E7%94%BB/","content":"使用 CSS 和 JavaScript 实现 iPhone 14 Pro “灵动岛” 动画\n背景：在我十八岁的最后一天 9.8 号，苹果公司召开秋季新品发布会，推出了 iPhone 14 等一系列产品。\n\n\n和大家一样，第一眼看到的时候我也觉得很惊艳，这丝滑带来的高级感，好灵动 😮！觉得厨子真是巧夺天工。作为一名前端学习者，我最感兴趣的当然是灵动岛动画的实现。经过一定的了解和学习后，那么让我们进入今天的主题，如何用 CSS 和 Javascript 来浅浅灵动一下。\n\n相关的前端知识本次分享会涉及前端三大件：\n\nHTML 定义了网页的内容\nCSS 描述了网页的布局\nJavaScript 控制了网页的行为\n\n\n让我们开始吧!首先我们先用 HTML 和 CSS 做出手机的静态页面\nHTML 代码\n&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;  &lt;head&gt;    &lt;link rel=&quot;stylesheet&quot; href=&quot;./style.css&quot; /&gt;    &lt;title&gt;Document&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;div class=&quot;iphone14Pro&quot;&gt;      &lt;div class=&quot;dynamic-island&quot;&gt;&lt;/div&gt;    &lt;/div&gt;  &lt;/body&gt;&lt;/html&gt;\n\nCSS 代码\n.iphone14Pro &#123;  position: relative;  margin: auto;  width: 974px;  height: 876px;  overflow: hidden;  background-image: url(https://www.apple.com.cn/v/iphone-14-pro/a/images/overview/dynamic-island/dynamic_hw__btl4fomgspyu_large.png);&#125;.dynamic-island &#123;  width: 320px;  margin-top: 72px;  margin: 72px auto 0;  background-color: red;  height: 80px;  border-radius: 40px;  position: relative;&#125;此处因为类名为dynamic-island的div内没有内容，所以用::before  和::after没有区别  .dynamic-island::before &#123;  position: absolute;  content: &quot; &quot;;  right: 0;  width: 80px;  height: 100%;  border-radius: 80px;  background-color: #272729;&#125;\n\n这样我们就得到了半部 iPhone 14Pro啦！(bushi)\n\n距离灵动岛只需要一点点 CSS 和 JS 就可以啦 😁\n\n一些 Web 动画的知识目前 web 动画在实现时主要有两种方式：CSS/ JS\n但是独立使用任何一个都不是最好的解决方案\n只用 CSS3 时，我们不好控制整个动画进程，如简单的点击触发动画，循环轮播整套动画等。\n只用 JS ，由于 JS 单线程的特性，所以在动画渲染时，性能不如 CSS3，可能出现不流畅情况。\n\n在 CSS3 中，也有两种实现灵动岛这样的过渡动画的方法： animation 和 transitionanimation 属性animatio 是很多属性的简写，我们简单介绍了解一下：\nanimation: name duration timing-function delay iteration-count direction  fill-mode;\n\nname: 代表一个由@keyframes定义的动画序列的名字\nduration ： 动画持续时间\ntiming-function ： 定义动画在每一动画周期中执行的节奏：CSS ease 各种效果的区别（ease 与 ease-in-out 的区别）_哔哩哔哩_bilibili\ndelay ： 动画开始前的延迟时间\niteration-count: 动画播放次数\ndirection： 指示动画是否反向播放\nfill-mode： 设置动画在执行之前和之后对应的样式选择\ntransition 属性transition 也是是很多属性的简写，我们简单介绍了解一下：\ntransition-property: 指定应用过渡属性的名称, 默认为 all\ntransition-duration： 过度动画的持续时间\ntransition-timing-function： 和上面的 timing-function 类似\ntransition-delay： 和上面的 delay 类似\n下面我们会分别使用这两个属性来实现动画效果\n\n灵动岛的具体实现我们今天简单实现下面四个常用的动画效果\n1.后台有音乐，倒计时，开热点，打电话等活动时，灵动岛变成长条① 我们先用 transition 属性来实现只需要在灵动岛的 CSS 上加上一个 transition 属性\ntransition:    width    cubic-bezier(0.3, 2, 1.0, 0.9)  0.8s;\t/*  灵动岛宽度变化时 遵循上面这个贝塞尔曲线函数  并在0.8s内完成 */然后我们用鼠标停在灵动岛模拟后台有活动.dynamic-island:hover &#123;width: 50vw;&#125; 让我们看看效果\n\n​ ② 我们用 animation 属性来实现\n​ 因为是给鼠标悬停时加动画，animation 的属性加在 hover 的伪类选择器上\n.dynamic-island:hover &#123;  animation: long 800ms ease-in-out forwards;  /*  当鼠标停在灵动岛上，触发名为long的动画，              0.8s内完成   且结束后定在最后一帧*/&#125;下面我们定义long 的动画 @keyframes long &#123;  0% &#123;  &#125;  60% &#123;    width: 50vw;  &#125;  80% &#123;    transform: scaleX(1.04);  &#125;  100% &#123;    transform: scaleX(1);    width: 50vw;  &#125;&#125;\n\n我们不难发现，要让动画有 “灵动感” ，动画的结尾往往表现出一种”超过预期大小，然后又缩回“ 的效果，在一伸一缩之中给了观众灵动的感觉。\n对比 transition 和 animation他们虽然都能做出“灵动感”，但是前者的实现会相对困难一些，虽然代码看起来简洁，但是贝塞尔曲线来描述理想的动画并没有直接用 animation 的定义关键帧写起来直观~\n所以下面的动画效果都用 animation 实现（肯定不是我偷懒 🙃）\n\n2.后台同时有两个活动的时候，灵动岛会分成两个部分（三个以上只显示两个）​ 我们用点击灵动岛给灵动岛加类名的方式，让灵动岛在不同动画间切换\n​ 灵动岛分成两部分的原理是把里面藏着的一个小球弹出，本身也做一个放大缩小的动感\n.divide &#123;  animation: divide-left 800ms ease-in-out forwards;&#125;@keyframes divide-left &#123;  0% &#123;  &#125;  40% &#123;    transform: scaleX(1.1);  &#125;  100% &#123;    transform: scaleX(1);  &#125;&#125;.divide::before &#123;  animation: divide-right 800ms ease-in-out forwards;&#125;@keyframes divide-right &#123;  0% &#123;  &#125;  40% &#123;    transform: scaleX(1.1);  &#125;  100% &#123;    transform: scaleX(1);    right: -100px;  &#125;&#125;\n\n\n3.关掉只剩一个后台任务时，两部分融合与分开成两部分类似，逆过程\n.fusion &#123;  animation: fusion-left 800ms ease-in-out forwards;&#125;@keyframes fusion-left &#123;  0% &#123;  &#125;  40% &#123;    transform: scaleX(1.1);  &#125;  100% &#123;    transform: scaleX(1);  &#125;&#125;.fusion::before &#123;  animation: fusion-right 800ms ease-in-out forwards;&#125;@keyframes fusion-right &#123;  0% &#123;    right: -100px;  &#125;  40% &#123;    transform: scaleX(1.1);  &#125;  100% &#123;    transform: scaleX(1);    right: 0;  &#125;&#125;\n\n\n4.长按唤出小组件的状态原理是把灵动岛变宽变长，小圆球设置为 display:none\n.bigger &#123;  animation: bigger 800ms ease-in-out forwards;&#125;@keyframes bigger &#123;  0% &#123;  &#125;  60% &#123;    width: 81vw;    height: 400px;    border-radius: 100px;  &#125;  80% &#123;    transform: scaleX(1.04);  &#125;  100% &#123;    width: 81vw;    height: 400px;    border-radius: 100px;    transform: scaleX(1);  &#125;&#125;.bigger::before &#123;  display: none;&#125;\n\n\nJS 代码实现const dynamicIsland = document.querySelector(&quot;.dynamic-island&quot;);let index = 0;animationList = [&quot;long&quot;, &quot;normal&quot;, &quot;divide&quot;, &quot;fusion&quot;, &quot;bigger&quot;, &quot;reset&quot;];dynamicIsland.addEventListener(&quot;click&quot;, () =&gt; &#123;  setTimeout(() =&gt; &#123;    if (index &lt;= animationList.length - 1) &#123;      dynamicIsland.classList.add(animationList[index]);      index++;    &#125; else &#123;      index = 0;      dynamicIsland.classList.remove(        &quot;long&quot;,        &quot;normal&quot;,        &quot;divide&quot;,        &quot;fusion&quot;,        &quot;bigger&quot;,        &quot;reset&quot;      );      dynamicIsland.classList.add(animationList[index]);    &#125;  &#125;, 100);&#125;);\n\n总结：iPhone 14 Pro 好不好用，灵动岛的实际体验到底好不好，我并没有资格评价(没用过）\n但是灵动岛这种新颖的交互方式和大胆创新的勇气，都值得我们学习\n好了今天分享就到这里，相信大家就算没有买 iPhone 14，也灵动了一把 😊。\n代码地址：Mingaaaaaaa/Dynamic-Island (github.com)\n"},{"title":"正则表达式学习笔记","url":"/2022/10/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"正则表达式学习笔记\n什么是正则表达式正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。\n正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串\n通配符： ？ 匹配 0 个或 1 个字符 *匹配零个或多个字符\n^ 匹配输入字符串的开始位置 [0-9 ] 匹配一个数字\n+ 前面的字符出现 1 次或多次 abc$匹配 abc ,并以 abc 结尾\n\n\n\n语法学习普通字符\n[aeiou] ：匹配字符串 “google runoob taobao” 中所有的 e o u a 字母\n[^aeiou] ： 匹配字符串 “google runoob taobao” 中除了 e o u a 字母的所有字母。\n[A-Z] ：匹配所有大写的字母\n. 匹配除换行符（\\n、\\r）之外的任何单个字符，相等于[^\\n\\r]。\n[\\s\\S]: 匹配所有。\\s 是匹配所有空白符，包括换行，\\S 非空白符，不包括换行。\n/w 匹配字母 数字 下划线 等价于 [A-Za-z0-9]\n\n\n特殊字符？, ., *, /, + 等等\n\n限定符* 前面子表达式出现零次或多次\n+ 匹配前面的子表达式一次或多次\n？匹配前面的子表达式零次或一次\n&#123;n&#125; ： 匹配 n 次 例如，o{2} 不能匹配 “Bob” 中的 o，但是能匹配 “food” 中的两个 o。\n&#123;n,&#125; ：至少匹配 n 次 例如，o{2,} 不能匹配 “Bob” 中的 o，但能匹配 “foooood” 中的所有 o。\n&#123;n,m&#125; ：匹配 n~m 次\n\n定位符^ ： 匹配字符串输入开始的位置\n$ ： 匹配字符串输入结束的位置\n\\b 匹配一个单词边界\n匹配单词边界稍有不同，但向正则表达式添加了很重要的能力。单词边界是单词和空格之间的位置。非单词边界是任何其他位置。下面的表达式匹配单词 Chapter 的开头三个字符，因为这三个字符出现在单词边界后面： Chapter\n/\\bCha/ ： 匹配在单词开头的 Cha 字符 /ter\\b/：匹配在单词结尾的 ter 字符\n\\B 非单词边检匹配\n\n选择\n\n用圆括号 () 将所有选择项括起来，相邻的选择项之间用 | 分隔。\n() 表示捕获分组，**()** 会把每个分组里的匹配的值保存起来，\n\n\n\n修饰符标记也称为修饰符，正则表达式的标记用于指定额外的匹配策略。\n标记不写在正则表达式里，标记位于表达式之外 如上面的/g\n/i : 不区分大小写\ng: 查找所有的匹配项\nm : 多行匹配\ns : 默认情况下的圆点 . 是匹配除换行符 \\n 之外的任何字符，加上 s 修饰符之后, . 中包含换行符 \\n。\n\n元字符建议直接查阅：(正则表达式 – 元字符 | 菜鸟教程 (runoob.com))\n列举一些重要的：\n\\cx 匹配有 x 指明的控制字符，例如， \\cM 匹配一个 Control-M 或回车符。\n\\d 等价于 [0-9]。\n\\D 等价于 [^0-9]\n\\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’\n\\W 匹配字母、数字、下划线。等价于’[^A-Za-z0-9_]’\n\n运算符的优先级正则表达式从左到右进行计算，并遵循优先级顺序，这与算术表达式非常类似。\n相同优先级的从左到右进行运算，不同优先级的运算先高后低。\n优先级高到低 ：\n\n\\ :转义符\n（），（？：），（？=），[] ：圆括号的方括号\n*, +, ?, {n}, {n,}, {n,m} 限定符\n^, $, \\任何元字符、任何字符\n| 替换，“或”操作\n\n\n实战演练：用尽可能精确的正则表达式描述南京邮电大学 19 至 22 级的所有本科生的学号\n/^(B|Q|P)(19|20|21)(0|1)\\d(0|1)\\d([0-5][1-9]|[1-5]0)/g\n\n"},{"title":"如何通过反编译获取小程序源码","url":"/2022/10/20/%E5%A6%82%E4%BD%95%E5%8F%8D%E7%BC%96%E8%AF%91%E8%8E%B7%E5%8F%96%E5%B0%8F%E7%A8%8B%E5%BA%8F%E4%BB%A3%E7%A0%81/","content":"10.22日更新微信PC端于 2.7.0 版本开始支持打开小程序，因此也可以直接在PC端打开小程序获取到pkg文件，pkg文件路径在微信默认保存位置下  WeChat Files\\Applet\\wx{…………}\\中\n但是直接拿去反编译会出现报错，原因是文件被加密了，需要先用解密工具解密，然后再反编译。\nError: Magic number is not correct!\n\n背景​        最近在学习怎么写小程序，在写练习小demo时想到，小程序并没有开发者工具，如果想学习其他优秀的小程序怎么写，并没有很好的途径去看源代码。而且小程序代码放在微信的服务器上，也不方便获取，如果有办法获取小程序的源码就好啦\n\n工具准备\nnode.js运行环境：\n后面用于运行node脚本 。下载地址：https://nodejs.org/en/\n\n反编译的脚本：\n源码链接 mirrors / xuedingmiaojun / wxappunpacker · GitCode\n\n夜神模拟器（不唯一，用于获取pkg文件）\n下载地址：https://www.yeshen.com/cn/download/fullPackage\n\n\n\n获取编译后的pkg文件在模拟器中登录微信，随便打开目标小程序\n打开文件管理器，找到/data/data/com.tencent.mm/MicroMsg 目录 ，然后找到一个很长的用户随机码，继续找到/appbrand/pkg/xxx，接下来会出现小程序A的wxapkg包\n\n\n\n  长按复制时间排序最新的那个文件，后点开右边工具栏的文件助手\n\n点击打开安卓文件夹，把刚刚复制的文件粘贴到安卓文件夹中\n\n然后我们就可以在电脑相应的路径下得到该pkg文件了\n安装脚本依赖并执行1.安装依赖\n 到达脚本文件所在处，打开命令行依次执行\nnpm installnpm install esprima    npm install css-tree    npm install cssbeautify    npm install vm2    npm install uglify-es    npm install js-beautify\n\n2.执行脚本命令\nnode  wuWxapkg.js C:\\Users\\pc-03\\Nox_share\\ImageShare\\xxx.wxapkg后面那个是pkg文件的地址，记得修改！\n\n3.编译结果\n\n编译成功\n\n\n编译失败\n\nModule build failed: Error: Cannot find module ‘escodegen’ \nnpm i --save-dev escodegen\nError: Cannot find module ‘cheerio’\nnpm install uglify-es --savenpm install esprima --savenpm install css-tree --savenpm install cssbeautify --savenpm install vm2 --savenpm install uglify-es --savenpm install js-beautify --savenpm install escodegen --savenpm install cheerio --save\n未识别的包说明拿到的两个.wxapkg文件里，当前反编译的包不是工程文件夹，再去管理器看下，是不是还有另一个文件呢！这个.wxapkg里面都是微信的基础包，是无需还原的！！！ \n\nSyntaxError: Unexpected end of input 解决wxss文件缺失问题修改wxappUnpacker中wuWxss.js部分代码，具体如下：\nfunction runVM(name,code)&#123; let wxAppCode=&#123;&#125;,handle=&#123;cssFile:name&#125;; let gg = new GwxCfg(); let tsandbox = &#123;$gwx:GwxCfg.prototype[&quot;$gwx&quot;],__mainPageFrameReady__:GwxCfg.prototype[&quot;$gwx&quot;],__wxAppCode__:wxAppCode,setCssToHead:cssRebuild.bind(handle)&#125;; let vm = new VM(&#123;sandbox:tsandbox&#125;); vm.run(code); for(let name in wxAppCode)if(name.endsWith(&quot;.wxss&quot;))&#123; handle.cssFile=path.resolve(frameName,&quot;..&quot;,name); wxAppCode[name](); &#125; /* let wxAppCode=&#123;&#125;,handle=&#123;cssFile:name&#125;; let vm=new VM(&#123;sandbox:Object.assign(new GwxCfg(),&#123;__wxAppCode__:wxAppCode,setCssToHead:cssRebuild.bind(handle)&#125;)&#125;); vm.run(code); for(let name in wxAppCode)if(name.endsWith(&quot;.wxss&quot;))&#123; handle.cssFile=path.resolve(frameName,&quot;..&quot;,name); wxAppCode[name](); &#125;*/ &#125;\n\n\n\n修改后再次编译，成功后同目录下就出现了完整的同名的文件夹了~\n\n\n\n总结​    前前后后花了大概一天时间完成了这个过程，小小开心一下。期间看网上很多教程都有不少纰漏，例如脚本源代码地址失效，获取文件方式繁琐且失败率高，脚本依赖安装不完整等等。所以决定记录下来，方便以后和大家一起学习交流~\n\n"}]